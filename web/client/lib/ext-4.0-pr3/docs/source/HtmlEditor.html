<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="http://localhost:3000/new/css/prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.form.HtmlEditor"></a>/**
 * @class Ext.form.HtmlEditor
 * @extends Ext.form.BaseField
 * Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be
 * automatically hidden when needed.  These are noted in the config options where appropriate.
 * &lt;br&gt;&lt;br&gt;The editor&#39;s toolbar buttons have tooltips defined in the {@link #buttonTips} property, but they are not
 * enabled by default unless the global {@link Ext.tip.QuickTips} singleton is {@link Ext.tip.QuickTips#init initialized}.
 * &lt;br&gt;&lt;br&gt;&lt;b&gt;Note: The focus/blur and validation marking functionality inherited from Ext.form.BaseField is NOT
 * supported by this editor.&lt;/b&gt;
 * &lt;br&gt;&lt;br&gt;An Editor is a sensitive component that can&#39;t be used in all spots standard fields can be used. Putting an Editor within
 * any element that has display set to &#39;none&#39; can cause problems in Safari and Firefox due to their default iframe reloading bugs.
 * &lt;br&gt;&lt;br&gt;Example usage:
 * <br><span style="display: none">**/</span>// Simple example rendered with default options:
Ext.tip.QuickTips.init();  // enable tooltips
new Ext.form.HtmlEditor({
    renderTo: Ext.getBody(),
    width: 800,
    height: 300
});

// Passed via xtype into a container and with custom options:
Ext.tip.QuickTips.init();  // enable tooltips
new Ext.panel.Panel({
    title: &#39;HTML Editor&#39;,
    renderTo: Ext.getBody(),
    width: 600,
    height: 300,
    frame: true,
    layout: &#39;fit&#39;,
    items: {
        xtype: &#39;htmleditor&#39;,
        enableColors: false,
        enableAlignments: false
    }
});
<br><span style="display: none">/**</span> * @constructor
 * Create a new HtmlEditor
 * @param {Object} config
 * @xtype htmleditor
 */

Ext.define(&#39;Ext.form.HtmlEditor&#39;, {
    extend:&#39;Ext.form.BaseField&#39;,
    alias: &#39;widget.htmleditor&#39;,
    requires: [&#39;Ext.tip.QuickTips&#39;, &#39;Ext.picker.Color&#39;, &#39;Ext.toolbar.Item&#39;, &#39;Ext.toolbar.Toolbar&#39;, &#39;Ext.util.Format&#39;],

    <a name="cfg-Ext.form.HtmlEditor-enableFormat"></a>/**
     * @cfg {Boolean} enableFormat Enable the bold, italic and underline buttons (defaults to true)
     */
    enableFormat : true,
    <a name="cfg-Ext.form.HtmlEditor-enableFontSize"></a>/**
     * @cfg {Boolean} enableFontSize Enable the increase/decrease font size buttons (defaults to true)
     */
    enableFontSize : true,
    <a name="cfg-Ext.form.HtmlEditor-enableColors"></a>/**
     * @cfg {Boolean} enableColors Enable the fore/highlight color buttons (defaults to true)
     */
    enableColors : true,
    <a name="cfg-Ext.form.HtmlEditor-enableAlignments"></a>/**
     * @cfg {Boolean} enableAlignments Enable the left, center, right alignment buttons (defaults to true)
     */
    enableAlignments : true,
    <a name="cfg-Ext.form.HtmlEditor-enableLists"></a>/**
     * @cfg {Boolean} enableLists Enable the bullet and numbered list buttons. Not available in Safari. (defaults to true)
     */
    enableLists : true,
    <a name="cfg-Ext.form.HtmlEditor-enableSourceEdit"></a>/**
     * @cfg {Boolean} enableSourceEdit Enable the switch to source edit button. Not available in Safari. (defaults to true)
     */
    enableSourceEdit : true,
    <a name="cfg-Ext.form.HtmlEditor-enableLinks"></a>/**
     * @cfg {Boolean} enableLinks Enable the create link button. Not available in Safari. (defaults to true)
     */
    enableLinks : true,
    <a name="cfg-Ext.form.HtmlEditor-enableFont"></a>/**
     * @cfg {Boolean} enableFont Enable font selection. Not available in Safari. (defaults to true)
     */
    enableFont : true,
    <a name="cfg-Ext.form.HtmlEditor-createLinkText"></a>/**
     * @cfg {String} createLinkText The default text for the create link prompt
     */
    createLinkText : &#39;Please enter the URL for the link:&#39;,
    <a name="cfg-Ext.form.HtmlEditor-defaultLinkValue"></a>/**
     * @cfg {String} defaultLinkValue The default value for the create link prompt (defaults to http:/ /)
     */
    defaultLinkValue : &#39;http:/&#39;+&#39;/&#39;,
    <a name="cfg-Ext.form.HtmlEditor-fontFamilies"></a>/**
     * @cfg {Array} fontFamilies An array of available font families
     */
    fontFamilies : [
        &#39;Arial&#39;,
        &#39;Courier New&#39;,
        &#39;Tahoma&#39;,
        &#39;Times New Roman&#39;,
        &#39;Verdana&#39;
    ],
    defaultFont: &#39;tahoma&#39;,
    <a name="cfg-Ext.form.HtmlEditor-defaultValue"></a>/**
     * @cfg {String} defaultValue A default value to be put into the editor to resolve focus issues (defaults to &amp;#160; (Non-breaking space) in Opera and IE6, &amp;#8203; (Zero-width space) in all other browsers).
     */
    defaultValue: (Ext.isOpera || Ext.isIE6) ? &#39;&amp;#160;&#39; : &#39;&amp;#8203;&#39;,

    // private properties
    actionMode: &#39;wrap&#39;,
    validationEvent : false,
    deferHeight: true,
    initialized : false,
    activated : false,
    sourceEditMode : false,
    onFocus : Ext.emptyFn,
    iframePad:3,
    hideMode:&#39;offsets&#39;,
    defaultAutoCreate : {
        tag: &quot;textarea&quot;,
        style:&quot;width:500px;height:300px;&quot;,
        autocomplete: &quot;off&quot;
    },

    // private
    initComponent : function(){
        this.addEvents(
            <a name="event-Ext.form.HtmlEditor-initialize"></a>/**
             * @event initialize
             * Fires when the editor is fully initialized (including the iframe)
             * @param {HtmlEditor} this
             */
            &#39;initialize&#39;,
            <a name="event-Ext.form.HtmlEditor-activate"></a>/**
             * @event activate
             * Fires when the editor is first receives the focus. Any insertion must wait
             * until after this event.
             * @param {HtmlEditor} this
             */
            &#39;activate&#39;,
             <a name="event-Ext.form.HtmlEditor-beforesync"></a>/**
             * @event beforesync
             * Fires before the textarea is updated with content from the editor iframe. Return false
             * to cancel the sync.
             * @param {HtmlEditor} this
             * @param {String} html
             */
            &#39;beforesync&#39;,
             <a name="event-Ext.form.HtmlEditor-beforepush"></a>/**
             * @event beforepush
             * Fires before the iframe editor is updated with content from the textarea. Return false
             * to cancel the push.
             * @param {HtmlEditor} this
             * @param {String} html
             */
            &#39;beforepush&#39;,
             <a name="event-Ext.form.HtmlEditor-sync"></a>/**
             * @event sync
             * Fires when the textarea is updated with content from the editor iframe.
             * @param {HtmlEditor} this
             * @param {String} html
             */
            &#39;sync&#39;,
             <a name="event-Ext.form.HtmlEditor-push"></a>/**
             * @event push
             * Fires when the iframe editor is updated with content from the textarea.
             * @param {HtmlEditor} this
             * @param {String} html
             */
            &#39;push&#39;,
             <a name="event-Ext.form.HtmlEditor-editmodechange"></a>/**
             * @event editmodechange
             * Fires when the editor switches edit modes
             * @param {HtmlEditor} this
             * @param {Boolean} sourceEdit True if source edit, false if standard editing.
             */
            &#39;editmodechange&#39;
        );
        Ext.form.HtmlEditor.superclass.initComponent.call(this);
    },

    // private
    createFontOptions : function(){
        var buf = [], fs = this.fontFamilies, ff, lc;
        for(var i = 0, len = fs.length; i&lt; len; i++){
            ff = fs[i];
            lc = ff.toLowerCase();
            buf.push(
                &#39;&lt;option value=&quot;&#39;,lc,&#39;&quot; style=&quot;font-family:&#39;,ff,&#39;;&quot;&#39;,
                    (this.defaultFont == lc ? &#39; selected=&quot;true&quot;&gt;&#39; : &#39;&gt;&#39;),
                    ff,
                &#39;&lt;/option&gt;&#39;
            );
        }
        return buf.join(&#39;&#39;);
    },

    /*
     * Protected method that will not generally be called directly. It
     * is called when the editor creates its toolbar. Override this method if you need to
     * add custom toolbar buttons.
     * @param {HtmlEditor} editor
     */
    createToolbar : function(editor){
        var items = [];
        var tipsEnabled = Ext.tip.QuickTips &amp;&amp; Ext.tip.QuickTips.isEnabled();


        function btn(id, toggle, handler){
            return {
                itemId : id,
                cls : Ext.baseCSSPrefix + &#39;btn-icon&#39;,
                iconCls: Ext.baseCSSPrefix + &#39;edit-&#39;+id,
                enableToggle:toggle !== false,
                scope: editor,
                handler:handler||editor.relayBtnCmd,
                clickEvent:&#39;mousedown&#39;,
                tooltip: tipsEnabled ? editor.buttonTips[id] || undefined : undefined,
                overflowText: editor.buttonTips[id].title || undefined,
                tabIndex:-1
            };
        }


        if(this.enableFont &amp;&amp; !Ext.isSafari2){
            var fontSelectItem = new Ext.toolbar.Item({
               autoEl: {
                    tag: &#39;select&#39;,
                    cls: Ext.baseCSSPrefix + &#39;font-select&#39;,
                    html: this.createFontOptions()
               }
            });

            items.push(
                fontSelectItem,
                &#39;-&#39;
            );
        }

        if(this.enableFormat){
            items.push(
                btn(&#39;bold&#39;),
                btn(&#39;italic&#39;),
                btn(&#39;underline&#39;)
            );
        }

        if(this.enableFontSize){
            items.push(
                &#39;-&#39;,
                btn(&#39;increasefontsize&#39;, false, this.adjustFont),
                btn(&#39;decreasefontsize&#39;, false, this.adjustFont)
            );
        }

        if(this.enableColors){
            items.push(
                &#39;-&#39;, {
                    itemId: &#39;forecolor&#39;,
                    cls: Ext.baseCSSPrefix + &#39;btn-icon&#39;,
                    iconCls: Ext.baseCSSPrefix + &#39;edit-forecolor&#39;,
                    clickEvent:&#39;mousedown&#39;,
                    tooltip: tipsEnabled ? editor.buttonTips.forecolor || undefined : undefined,
                    tabIndex:-1,
                    menu : new Ext.picker.Color({
                        allowReselect: true,
                        focus: Ext.emptyFn,
                        value:&#39;000000&#39;,
                        plain:true,
                        listeners: {
                            scope: this,
                            select: function(cp, color){
                                this.execCmd(&#39;forecolor&#39;, Ext.isWebKit || Ext.isIE ? &#39;#&#39;+color : color);
                                this.deferFocus();
                            }
                        },
                        clickEvent:&#39;mousedown&#39;
                    })
                }, {
                    itemId: &#39;backcolor&#39;,
                    cls: Ext.baseCSSPrefix + &#39;btn-icon&#39;,
                    iconCls: Ext.baseCSSPrefix + &#39;edit-backcolor&#39;,
                    clickEvent:&#39;mousedown&#39;,
                    tooltip: tipsEnabled ? editor.buttonTips.backcolor || undefined : undefined,
                    tabIndex:-1,
                    menu : new Ext.picker.Color({
                        focus: Ext.emptyFn,
                        value:&#39;FFFFFF&#39;,
                        plain:true,
                        allowReselect: true,
                        listeners: {
                            scope: this,
                            select: function(cp, color){
                                if(Ext.isGecko){
                                    this.execCmd(&#39;useCSS&#39;, false);
                                    this.execCmd(&#39;hilitecolor&#39;, color);
                                    this.execCmd(&#39;useCSS&#39;, true);
                                    this.deferFocus();
                                }else{
                                    this.execCmd(Ext.isOpera ? &#39;hilitecolor&#39; : &#39;backcolor&#39;, Ext.isWebKit || Ext.isIE ? &#39;#&#39;+color : color);
                                    this.deferFocus();
                                }
                            }
                        },
                        clickEvent:&#39;mousedown&#39;
                    })
                }
            );
        }

        if(this.enableAlignments){
            items.push(
                &#39;-&#39;,
                btn(&#39;justifyleft&#39;),
                btn(&#39;justifycenter&#39;),
                btn(&#39;justifyright&#39;)
            );
        }

        if(!Ext.isSafari2){
            if(this.enableLinks){
                items.push(
                    &#39;-&#39;,
                    btn(&#39;createlink&#39;, false, this.createLink)
                );
            }

            if(this.enableLists){
                items.push(
                    &#39;-&#39;,
                    btn(&#39;insertorderedlist&#39;),
                    btn(&#39;insertunorderedlist&#39;)
                );
            }
            if(this.enableSourceEdit){
                items.push(
                    &#39;-&#39;,
                    btn(&#39;sourceedit&#39;, true, function(btn){
                        this.toggleSourceEdit(!this.sourceEditMode);
                    })
                );
            }
        }

        // build the toolbar
        var tb = new Ext.toolbar.Toolbar({
            renderTo: this.wrap.dom.firstChild,
            items: items
        });

        if (fontSelectItem) {
            this.fontSelect = fontSelectItem.el;

            this.mon(this.fontSelect, &#39;change&#39;, function(){
                var font = this.fontSelect.dom.value;
                this.relayCmd(&#39;fontname&#39;, font);
                this.deferFocus();
            }, this);
        }

        // stop form submits
        this.mon(tb.el, &#39;click&#39;, function(e){
            e.preventDefault();
        });

        this.tb = tb;
        this.tb.doLayout();
    },

    onDisable: function(){
        this.wrap.mask();
        Ext.form.HtmlEditor.superclass.onDisable.call(this);
    },

    onEnable: function(){
        this.wrap.unmask();
        Ext.form.HtmlEditor.superclass.onEnable.call(this);
    },

    setReadOnly: function(readOnly){

        Ext.form.HtmlEditor.superclass.setReadOnly.call(this, readOnly);
        if(this.initialized){
            if(Ext.isIE){
                this.getEditorBody().contentEditable = !readOnly;
            }else{
                this.setDesignMode(!readOnly);
            }
            var bd = this.getEditorBody();
            if(bd){
                bd.style.cursor = this.readOnly ? &#39;default&#39; : &#39;text&#39;;
            }
            this.disableItems(readOnly);
        }
    },

    <a name="method-Ext.form.HtmlEditor-getDocMarkup"></a>/**
     * Protected method that will not generally be called directly. It
     * is called when the editor initializes the iframe with HTML contents. Override this method if you
     * want to change the initialization markup of the iframe (e.g. to add stylesheets).
     *
     * Note: IE8-Standards has unwanted scroller behavior, so the default meta tag forces IE7 compatibility
     */
    getDocMarkup : function(){
        var h = Ext.fly(this.iframe).getHeight() - this.iframePad * 2;
        return Ext.String.format(&#39;&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;body{border: 0; margin: 0; padding: {0}px; height: {1}px; cursor: text}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;, this.iframePad, h);
    },

    // private
    getEditorBody : function(){
        var doc = this.getDoc();
        return doc.body || doc.documentElement;
    },

    // private
    getDoc : function(){
        return Ext.isIE ? this.getWin().document : (this.iframe.contentDocument || this.getWin().document);
    },

    // private
    getWin : function(){
        return Ext.isIE ? this.iframe.contentWindow : window.frames[this.iframe.name];
    },

    // private
    onRender : function(ct, position){
        Ext.form.HtmlEditor.superclass.onRender.call(this, ct, position);
        this.el.dom.style.border = &#39;0 none&#39;;
        this.el.dom.setAttribute(&#39;tabIndex&#39;, -1);
        this.el.addCls(Ext.baseCSSPrefix + &#39;hidden&#39;);
        if(Ext.isIE){ // fix IE 1px bogus margin
            this.el.applyStyles(&#39;margin-top:-1px;margin-bottom:-1px;&#39;);
        }
        this.wrap = this.el.wrap({
            cls: Ext.baseCSSPrefix + &#39;html-editor-wrap&#39;, cn:{cls: Ext.baseCSSPrefix + &#39;html-editor-tb&#39;}
        });

        this.createToolbar(this);

        this.disableItems(true);

        this.tb.doLayout();

        this.createIFrame();

        if(!this.width){
            var sz = this.el.getSize();
            this.setSize(sz.width, this.height || sz.height);
        }
        this.resizeEl = this.positionEl = this.wrap;
    },

    createIFrame: function(){
        var iframe = document.createElement(&#39;iframe&#39;);
        iframe.name = Ext.id();
        iframe.frameBorder = &#39;0&#39;;
        iframe.style.overflow = &#39;auto&#39;;
        iframe.src = Ext.SSL_SECURE_URL;

        this.wrap.dom.appendChild(iframe);
        this.iframe = iframe;

        this.monitorTask = Ext.TaskMgr.start({
            run: this.checkDesignMode,
            scope: this,
            interval:100
        });
    },

    initFrame : function(){
        Ext.TaskMgr.stop(this.monitorTask);
        var doc = this.getDoc();
        this.win = this.getWin();

        doc.open();
        doc.write(this.getDocMarkup());
        doc.close();

        var task = { // must defer to wait for browser to be ready
            run : function(){
                var doc = this.getDoc();
                if(doc.body || doc.readyState == &#39;complete&#39;){
                    Ext.TaskMgr.stop(task);
                    this.setDesignMode(true);
                     Ext.defer(this.initEditor, 10, this);
                }
            },
            interval : 10,
            duration:10000,
            scope: this
        };
        Ext.TaskMgr.start(task);
    },


    checkDesignMode : function(){
        if(this.wrap &amp;&amp; this.wrap.dom.offsetWidth){
            var doc = this.getDoc();
            if(!doc){
                return;
            }
            if(!doc.editorInitialized || this.getDesignMode() != &#39;on&#39;){
                this.initFrame();
            }
        }
    },

    /* private
     * set current design mode. To enable, mode can be true or &#39;on&#39;, off otherwise
     */
    setDesignMode : function(mode){
        var doc = this.getDoc();
        if (doc) {
            if(this.readOnly){
                mode = false;
            }
            doc.designMode = (/on|true/i).test(String(mode).toLowerCase()) ?&#39;on&#39;:&#39;off&#39;;
        }

    },

    // private
    getDesignMode : function(){
        var doc = this.getDoc();
        if(!doc){ return &#39;&#39;; }
        return String(doc.designMode).toLowerCase();

    },

    disableItems: function(disabled){
        if(this.fontSelect){
            this.fontSelect.dom.disabled = disabled;
        }
        this.tb.items.each(function(item){
            if(item.getItemId() != &#39;sourceedit&#39;){
                item.setDisabled(disabled);
            }
        });
    },

    // private
    onResize : function(w, h){
        Ext.form.HtmlEditor.superclass.onResize.apply(this, arguments);
        if(this.el &amp;&amp; this.iframe){
            if(Ext.isNumber(w)){
                var aw = w - this.wrap.getFrameWidth(&#39;lr&#39;);
                this.el.setWidth(aw);
                this.tb.setWidth(aw);
                this.iframe.style.width = Math.max(aw, 0) + &#39;px&#39;;
            }
            if(Ext.isNumber(h)){
                var ah = h - this.wrap.getFrameWidth(&#39;tb&#39;) - this.tb.el.getHeight();
                this.el.setHeight(ah);
                this.iframe.style.height = Math.max(ah, 0) + &#39;px&#39;;
                var bd = this.getEditorBody();
                if(bd){
                    bd.style.height = Math.max((ah - (this.iframePad*2)), 0) + &#39;px&#39;;
                }
            }
        }
    },

    <a name="method-Ext.form.HtmlEditor-toggleSourceEdit"></a>/**
     * Toggles the editor between standard and source edit mode.
     * @param {Boolean} sourceEdit (optional) True for source edit, false for standard
     */
    toggleSourceEdit : function(sourceEditMode){
        var iframeHeight,
            elHeight;

        if (sourceEditMode === undefined) {
            sourceEditMode = !this.sourceEditMode;
        }
        this.sourceEditMode = sourceEditMode === true;
        var btn = this.tb.getComponent(&#39;sourceedit&#39;);

        if (btn.pressed !== this.sourceEditMode) {
            btn.toggle(this.sourceEditMode);
            if (!btn.xtbHidden) {
                return;
            }
        }
        if (this.sourceEditMode) {
            // grab the height of the containing panel before we hide the iframe
            this.previousSize = this.getSize();

            iframeHeight = Ext.get(this.iframe).getHeight();

            this.disableItems(true);
            this.syncValue();
            this.iframe.className = Ext.baseCSSPrefix + &#39;hidden&#39;;
            this.el.removeCls(Ext.baseCSSPrefix + &#39;hidden&#39;);
            this.el.dom.removeAttribute(&#39;tabIndex&#39;);
            this.el.focus();
            this.el.dom.style.height = iframeHeight + &#39;px&#39;;
        }
        else {
            elHeight = parseInt(this.el.dom.style.height, 10);
            if (this.initialized) {
                this.disableItems(this.readOnly);
            }
            this.pushValue();
            this.iframe.className = &#39;&#39;;
            this.el.addCls(Ext.baseCSSPrefix + &#39;hidden&#39;);
            this.el.dom.setAttribute(&#39;tabIndex&#39;, -1);
            this.deferFocus();

            this.setSize(this.previousSize);
            delete this.previousSize;
            this.iframe.style.height = elHeight + &#39;px&#39;;
        }
        this.fireEvent(&#39;editmodechange&#39;, this, this.sourceEditMode);
    },

    // private used internally
    createLink : function() {
        var url = prompt(this.createLinkText, this.defaultLinkValue);
        if(url &amp;&amp; url != &#39;http:/&#39;+&#39;/&#39;){
            this.relayCmd(&#39;createlink&#39;, url);
        }
    },

    // private
    initEvents : function(){
        this.originalValue = this.getValue();
    },

    <a name="method-Ext.form.HtmlEditor-markInvalid"></a>/**
     * Overridden and disabled. The editor element does not support standard valid/invalid marking. @hide
     * @method
     */
    markInvalid : Ext.emptyFn,

    <a name="method-Ext.form.HtmlEditor-clearInvalid"></a>/**
     * Overridden and disabled. The editor element does not support standard valid/invalid marking. @hide
     * @method
     */
    clearInvalid : Ext.emptyFn,

    // docs inherit from Field
    setValue : function(v){
        Ext.form.HtmlEditor.superclass.setValue.call(this, v);
        this.pushValue();
        return this;
    },

    <a name="method-Ext.form.HtmlEditor-cleanHtml"></a>/**
     * Protected method that will not generally be called directly. If you need/want
     * custom HTML cleanup, this is the method you should override.
     * @param {String} html The HTML to be cleaned
     * @return {String} The cleaned HTML
     */
    cleanHtml: function(html) {
        html = String(html);
        if(Ext.isWebKit){ // strip safari nonsense
            html = html.replace(/\sclass=&quot;(?:Apple-style-span|khtml-block-placeholder)&quot;/gi, &#39;&#39;);
        }

        /*
         * Neat little hack. Strips out all the non-digit characters from the default
         * value and compares it to the character code of the first character in the string
         * because it can cause encoding issues when posted to the server.
         */
        if(html.charCodeAt(0) == this.defaultValue.replace(/\D/g, &#39;&#39;)){
            html = html.substring(1);
        }
        return html;
    },

    <a name="method-Ext.form.HtmlEditor-syncValue"></a>/**
     * Protected method that will not generally be called directly. Syncs the contents
     * of the editor iframe with the textarea.
     */
    syncValue : function(){
        if(this.initialized){
            var bd = this.getEditorBody();
            var html = bd.innerHTML;
            if(Ext.isWebKit){
                var bs = bd.getAttribute(&#39;style&#39;); // Safari puts text-align styles on the body element!
                var m = bs.match(/text-align:(.*?);/i);
                if(m &amp;&amp; m[1]){
                    html = &#39;&lt;div style=&quot;&#39;+m[0]+&#39;&quot;&gt;&#39; + html + &#39;&lt;/div&gt;&#39;;
                }
            }
            html = this.cleanHtml(html);
            if(this.fireEvent(&#39;beforesync&#39;, this, html) !== false){
                this.el.dom.value = html;
                this.fireEvent(&#39;sync&#39;, this, html);
            }
        }
    },

    //docs inherit from Field
    getValue : function() {
        this[this.sourceEditMode ? &#39;pushValue&#39; : &#39;syncValue&#39;]();
        return Ext.form.HtmlEditor.superclass.getValue.call(this);
    },

    <a name="method-Ext.form.HtmlEditor-pushValue"></a>/**
     * Protected method that will not generally be called directly. Pushes the value of the textarea
     * into the iframe editor.
     */
    pushValue : function(){
        if(this.initialized){
            var v = this.el.dom.value;
            if(!this.activated &amp;&amp; v.length &lt; 1){
                v = this.defaultValue;
            }
            if(this.fireEvent(&#39;beforepush&#39;, this, v) !== false){
                this.getEditorBody().innerHTML = v;
                if(Ext.isGecko){
                    // Gecko hack, see: https://bugzilla.mozilla.org/show_bug.cgi?id=232791#c8
                    this.setDesignMode(false);  //toggle off first
                    this.setDesignMode(true);
                }
                this.fireEvent(&#39;push&#39;, this, v);
            }

        }
    },

    // private
    deferFocus : function(){
         Ext.defer(this.focus, 10, this);
    },

    // docs inherit from Field
    focus : function(){
        if(this.win &amp;&amp; !this.sourceEditMode){
            this.win.focus();
        }else{
            this.el.focus();
        }
    },

    // private
    initEditor : function(){
        //Destroying the component during/before initEditor can cause issues.
        try{
            var dbody = this.getEditorBody(),
                ss = this.el.getStyles(&#39;font-size&#39;, &#39;font-family&#39;, &#39;background-image&#39;, &#39;background-repeat&#39;, &#39;background-color&#39;, &#39;color&#39;),
                doc,
                fn;

            ss[&#39;background-attachment&#39;] = &#39;fixed&#39;; // w3c
            dbody.bgProperties = &#39;fixed&#39;; // ie

            Ext.core.DomHelper.applyStyles(dbody, ss);

            doc = this.getDoc();

            if(doc){
                try{
                    Ext.EventManager.removeAll(doc);
                }catch(e){}
            }

            /*
             * We need to use createDelegate here, because when using buffer, the delayed task is added
             * as a property to the function. When the listener is removed, the task is deleted from the function.
             * Since onEditorEvent is shared on the prototype, if we have multiple html editors, the first time one of the editors
             * is destroyed, it causes the fn to be deleted from the prototype, which causes errors. Essentially, we&#39;re just anonymizing the function.
             */
            fn = Ext.Function.bind(this.onEditorEvent, this);
            Ext.EventManager.on(doc, {
                mousedown: fn,
                dblclick: fn,
                click: fn,
                keyup: fn,
                buffer:100
            });

            if(Ext.isGecko){
                Ext.EventManager.on(doc, &#39;keypress&#39;, this.applyCommand, this);
            }
            if(Ext.isIE || Ext.isWebKit || Ext.isOpera){
                Ext.EventManager.on(doc, &#39;keydown&#39;, this.fixKeys, this);
            }
            doc.editorInitialized = true;
            this.initialized = true;
            this.pushValue();
            this.setReadOnly(this.readOnly);
            this.fireEvent(&#39;initialize&#39;, this);
        }catch(e){}
    },

    // private
    beforeDestroy : function(){
        if(this.monitorTask){
            Ext.TaskMgr.stop(this.monitorTask);
        }
        if(this.rendered){
            Ext.destroy(this.tb);
            var doc = this.getDoc();
            if(doc){
                try{
                    Ext.EventManager.removeAll(doc);
                    for (var prop in doc){
                        delete doc[prop];
                    }
                }catch(e){}
            }
            if(this.wrap){
                this.wrap.dom.innerHTML = &#39;&#39;;
                this.wrap.remove();
            }
        }
        Ext.form.HtmlEditor.superclass.beforeDestroy.call(this);
    },

    // private
    onFirstFocus : function(){
        this.activated = true;
        this.disableItems(this.readOnly);
        if(Ext.isGecko){ // prevent silly gecko errors
            this.win.focus();
            var s = this.win.getSelection();
            if(!s.focusNode || s.focusNode.nodeType != 3){
                var r = s.getRangeAt(0);
                r.selectNodeContents(this.getEditorBody());
                r.collapse(true);
                this.deferFocus();
            }
            try{
                this.execCmd(&#39;useCSS&#39;, true);
                this.execCmd(&#39;styleWithCSS&#39;, false);
            }catch(e){}
        }
        this.fireEvent(&#39;activate&#39;, this);
    },

    // private
    adjustFont: function(btn){
        var adjust = btn.getItemId() == &#39;increasefontsize&#39; ? 1 : -1,
            doc = this.getDoc(),
            v = parseInt(doc.queryCommandValue(&#39;FontSize&#39;) || 2, 10);
        if((Ext.isSafari &amp;&amp; !Ext.isSafari2) || Ext.isChrome || Ext.isAir){
            // Safari 3 values
            // 1 = 10px, 2 = 13px, 3 = 16px, 4 = 18px, 5 = 24px, 6 = 32px
            if(v &lt;= 10){
                v = 1 + adjust;
            }else if(v &lt;= 13){
                v = 2 + adjust;
            }else if(v &lt;= 16){
                v = 3 + adjust;
            }else if(v &lt;= 18){
                v = 4 + adjust;
            }else if(v &lt;= 24){
                v = 5 + adjust;
            }else {
                v = 6 + adjust;
            }
            v = Ext.Number.constrain(v, 1, 6);
        }else{
            if(Ext.isSafari){ // safari
                adjust *= 2;
            }
            v = Math.max(1, v+adjust) + (Ext.isSafari ? &#39;px&#39; : 0);
        }
        this.execCmd(&#39;FontSize&#39;, v);
    },

    // private
    onEditorEvent : function(e){
        this.updateToolbar();
    },


    <a name="method-Ext.form.HtmlEditor-updateToolbar"></a>/**
     * Protected method that will not generally be called directly. It triggers
     * a toolbar update by reading the markup state of the current selection in the editor.
     */
    updateToolbar: function(){

        if(this.readOnly){
            return;
        }

        if(!this.activated){
            this.onFirstFocus();
            return;
        }

        var btns = this.tb.items.map,
            doc = this.getDoc();

        if(this.enableFont &amp;&amp; !Ext.isSafari2){
            var name = (doc.queryCommandValue(&#39;FontName&#39;)||this.defaultFont).toLowerCase();
            if(name != this.fontSelect.dom.value){
                this.fontSelect.dom.value = name;
            }
        }
        if(this.enableFormat){
            btns.bold.toggle(doc.queryCommandState(&#39;bold&#39;));
            btns.italic.toggle(doc.queryCommandState(&#39;italic&#39;));
            btns.underline.toggle(doc.queryCommandState(&#39;underline&#39;));
        }
        if(this.enableAlignments){
            btns.justifyleft.toggle(doc.queryCommandState(&#39;justifyleft&#39;));
            btns.justifycenter.toggle(doc.queryCommandState(&#39;justifycenter&#39;));
            btns.justifyright.toggle(doc.queryCommandState(&#39;justifyright&#39;));
        }
        if(!Ext.isSafari2 &amp;&amp; this.enableLists){
            btns.insertorderedlist.toggle(doc.queryCommandState(&#39;insertorderedlist&#39;));
            btns.insertunorderedlist.toggle(doc.queryCommandState(&#39;insertunorderedlist&#39;));
        }

        Ext.menu.MenuManager.hideAll();

        this.syncValue();
    },

    // private
    relayBtnCmd : function(btn){
        this.relayCmd(btn.getItemId());
    },

    <a name="method-Ext.form.HtmlEditor-relayCmd"></a>/**
     * Executes a Midas editor command on the editor document and performs necessary focus and
     * toolbar updates. &lt;b&gt;This should only be called after the editor is initialized.&lt;/b&gt;
     * @param {String} cmd The Midas command
     * @param {String/Boolean} value (optional) The value to pass to the command (defaults to null)
     */
    relayCmd : function(cmd, value){
        Ext.defer(function(){
            this.focus();
            this.execCmd(cmd, value);
            this.updateToolbar();
        }, 10, this);
    },

    <a name="method-Ext.form.HtmlEditor-execCmd"></a>/**
     * Executes a Midas editor command directly on the editor document.
     * For visual commands, you should use {@link #relayCmd} instead.
     * &lt;b&gt;This should only be called after the editor is initialized.&lt;/b&gt;
     * @param {String} cmd The Midas command
     * @param {String/Boolean} value (optional) The value to pass to the command (defaults to null)
     */
    execCmd : function(cmd, value){
        var doc = this.getDoc();
        doc.execCommand(cmd, false, value === undefined ? null : value);
        this.syncValue();
    },

    // private
    applyCommand : function(e){
        if(e.ctrlKey){
            var c = e.getCharCode(), cmd;
            if(c &gt; 0){
                c = String.fromCharCode(c);
                switch(c){
                    case &#39;b&#39;:
                        cmd = &#39;bold&#39;;
                    break;
                    case &#39;i&#39;:
                        cmd = &#39;italic&#39;;
                    break;
                    case &#39;u&#39;:
                        cmd = &#39;underline&#39;;
                    break;
                }
                if(cmd){
                    this.win.focus();
                    this.execCmd(cmd);
                    this.deferFocus();
                    e.preventDefault();
                }
            }
        }
    },

    <a name="method-Ext.form.HtmlEditor-insertAtCursor"></a>/**
     * Inserts the passed text at the current cursor position. Note: the editor must be initialized and activated
     * to insert text.
     * @param {String} text
     */
    insertAtCursor : function(text){
        if(!this.activated){
            return;
        }
        if(Ext.isIE){
            this.win.focus();
            var doc = this.getDoc(),
                r = doc.selection.createRange();
            if(r){
                r.pasteHTML(text);
                this.syncValue();
                this.deferFocus();
            }
        }else{
            this.win.focus();
            this.execCmd(&#39;InsertHTML&#39;, text);
            this.deferFocus();
        }
    },

    // private
    fixKeys : function(){ // load time branching for fastest keydown performance
        if(Ext.isIE){
            return function(e){
                var k = e.getKey(),
                    doc = this.getDoc(),
                        r;
                if(k == e.TAB){
                    e.stopEvent();
                    r = doc.selection.createRange();
                    if(r){
                        r.collapse(true);
                        r.pasteHTML(&#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#39;);
                        this.deferFocus();
                    }
                }else if(k == e.ENTER){
                    r = doc.selection.createRange();
                    if(r){
                        var target = r.parentElement();
                        if(!target || target.tagName.toLowerCase() != &#39;li&#39;){
                            e.stopEvent();
                            r.pasteHTML(&#39;&lt;br /&gt;&#39;);
                            r.collapse(false);
                            r.select();
                        }
                    }
                }
            };
        }else if(Ext.isOpera){
            return function(e){
                var k = e.getKey();
                if(k == e.TAB){
                    e.stopEvent();
                    this.win.focus();
                    this.execCmd(&#39;InsertHTML&#39;,&#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#39;);
                    this.deferFocus();
                }
            };
        }else if(Ext.isWebKit){
            return function(e){
                var k = e.getKey();
                if(k == e.TAB){
                    e.stopEvent();
                    this.execCmd(&#39;InsertText&#39;,&#39;\t&#39;);
                    this.deferFocus();
                }else if(k == e.ENTER){
                    e.stopEvent();
                    this.execCmd(&#39;InsertHtml&#39;,&#39;&lt;br /&gt;&lt;br /&gt;&#39;);
                    this.deferFocus();
                }
             };
        }
    }(),

    <a name="method-Ext.form.HtmlEditor-getToolbar"></a>/**
     * Returns the editor&#39;s toolbar. &lt;b&gt;This is only available after the editor has been rendered.&lt;/b&gt;
     * @return {Ext.toolbar.Toolbar}
     */
    getToolbar : function(){
        return this.tb;
    },

    <a name="prop-Ext.form.HtmlEditor-buttonTips"></a>/**
     * Object collection of toolbar tooltips for the buttons in the editor. The key
     * is the command id associated with that button and the value is a valid QuickTips object.
     * For example:
<br><span style="display: none">**/</span>{
    bold : {
        title: &#39;Bold (Ctrl+B)&#39;,
        text: &#39;Make the selected text bold.&#39;,
        cls: &#39;x-html-editor-tip&#39;
    },
    italic : {
        title: &#39;Italic (Ctrl+I)&#39;,
        text: &#39;Make the selected text italic.&#39;,
        cls: &#39;x-html-editor-tip&#39;
    },
    ...
<br><span style="display: none">/**</span>    * @type Object
     */
    buttonTips : {
        bold : {
            title: &#39;Bold (Ctrl+B)&#39;,
            text: &#39;Make the selected text bold.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        italic : {
            title: &#39;Italic (Ctrl+I)&#39;,
            text: &#39;Make the selected text italic.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        underline : {
            title: &#39;Underline (Ctrl+U)&#39;,
            text: &#39;Underline the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        increasefontsize : {
            title: &#39;Grow Text&#39;,
            text: &#39;Increase the font size.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        decreasefontsize : {
            title: &#39;Shrink Text&#39;,
            text: &#39;Decrease the font size.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        backcolor : {
            title: &#39;Text Highlight Color&#39;,
            text: &#39;Change the background color of the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        forecolor : {
            title: &#39;Font Color&#39;,
            text: &#39;Change the color of the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifyleft : {
            title: &#39;Align Text Left&#39;,
            text: &#39;Align text to the left.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifycenter : {
            title: &#39;Center Text&#39;,
            text: &#39;Center text in the editor.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifyright : {
            title: &#39;Align Text Right&#39;,
            text: &#39;Align text to the right.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        insertunorderedlist : {
            title: &#39;Bullet List&#39;,
            text: &#39;Start a bulleted list.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        insertorderedlist : {
            title: &#39;Numbered List&#39;,
            text: &#39;Start a numbered list.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        createlink : {
            title: &#39;Hyperlink&#39;,
            text: &#39;Make the selected text a hyperlink.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        sourceedit : {
            title: &#39;Source Edit&#39;,
            text: &#39;Switch to source editing mode.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        }
    }

    // hide stuff that is not compatible
    <a name="event-Ext.form.HtmlEditor-blur"></a>/**
     * @event blur
     * @hide
     */
    <a name="event-Ext.form.HtmlEditor-change"></a>/**
     * @event change
     * @hide
     */
    <a name="event-Ext.form.HtmlEditor-focus"></a>/**
     * @event focus
     * @hide
     */
    <a name="event-Ext.form.HtmlEditor-specialkey"></a>/**
     * @event specialkey
     * @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-fieldCls"></a>/**
     * @cfg {String} fieldCls @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-focusCls"></a>/**
     * @cfg {String} focusCls @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-autoCreate"></a>/**
     * @cfg {String} autoCreate @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-inputType"></a>/**
     * @cfg {String} inputType @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-invalidCls"></a>/**
     * @cfg {String} invalidCls @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-invalidText"></a>/**
     * @cfg {String} invalidText @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-msgFx"></a>/**
     * @cfg {String} msgFx @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-validateOnBlur"></a>/**
     * @cfg {String} validateOnBlur @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-allowDomMove"></a>/**
     * @cfg {Boolean} allowDomMove  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-applyTo"></a>/**
     * @cfg {String} applyTo @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-autoHeight"></a>/**
     * @cfg {String} autoHeight  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-autoWidth"></a>/**
     * @cfg {String} autoWidth  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-cls"></a>/**
     * @cfg {String} cls  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-disabled"></a>/**
     * @cfg {String} disabled  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-disabledCls"></a>/**
     * @cfg {String} disabledCls  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-msgTarget"></a>/**
     * @cfg {String} msgTarget  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-readOnly"></a>/**
     * @cfg {String} readOnly  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-style"></a>/**
     * @cfg {String} style  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-validationDelay"></a>/**
     * @cfg {String} validationDelay  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-validationEvent"></a>/**
     * @cfg {String} validationEvent  @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-tabIndex"></a>/**
     * @cfg {String} tabIndex  @hide
     */
    <a name="prop-Ext.form.HtmlEditor-disabled"></a>/**
     * @property disabled
     * @hide
     */
    <a name="method-Ext.form.HtmlEditor-applyToMarkup"></a>/**
     * @method applyToMarkup
     * @hide
     */
    <a name="method-Ext.form.HtmlEditor-disable"></a>/**
     * @method disable
     * @hide
     */
    <a name="method-Ext.form.HtmlEditor-enable"></a>/**
     * @method enable
     * @hide
     */
    <a name="method-Ext.form.HtmlEditor-validate"></a>/**
     * @method validate
     * @hide
     */
    <a name="event-Ext.form.HtmlEditor-valid"></a>/**
     * @event valid
     * @hide
     */
    <a name="method-Ext.form.HtmlEditor-setDisabled"></a>/**
     * @method setDisabled
     * @hide
     */
    <a name="cfg-Ext.form.HtmlEditor-null"></a>/**
     * @cfg keys
     * @hide
     */
});
￿</pre></pre></body></html>