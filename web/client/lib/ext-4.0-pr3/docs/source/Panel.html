<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="http://localhost:3000/new/css/prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.panel.Panel"></a>/**
 * @class Ext.panel.Panel
 * @extends Ext.AbstractPanel
 * &lt;p&gt;Panel is a container that has specific functionality and structural components that make
 * it the perfect building block for application-oriented user interfaces.&lt;/p&gt;
 * &lt;p&gt;Panels are, by virtue of their inheritance from {@link Ext.container.Container}, capable
 * of being configured with a {@link Ext.container.Container#layout layout}, and containing child Components.&lt;/p&gt;
 * &lt;p&gt;When either specifying child {@link Ext.Component#items items} of a Panel, or dynamically {@link Ext.container.Container#add adding} Components
 * to a Panel, remember to consider how you wish the Panel to arrange those child elements, and whether
 * those child elements need to be sized using one of Ext&#39;s built-in &lt;code&gt;&lt;b&gt;{@link Ext.container.Container#layout layout}&lt;/b&gt;&lt;/code&gt; schemes. By
 * default, Panels use the {@link Ext.layout.Container ContainerLayout} scheme. This simply renders
 * child components, appending them one after the other inside the Container, and &lt;b&gt;does not apply any sizing&lt;/b&gt;
 * at all.&lt;/p&gt;
 * &lt;p&gt;A Panel may also contain {@link #bbar bottom} and {@link #tbar top} toolbars, along with separate
 * {@link #header}, {@link #footer} and {@link #body} sections (see {@link #frame} for additional
 * information).&lt;/p&gt;
 * &lt;p&gt;Panel also provides built-in {@link #collapsible expandable and collapsible behavior}, along with
 * a variety of {@link #tools prebuilt tool buttons} that can be wired up to provide other customized
 * behavior.  Panels can be easily dropped into any {@link Ext.container.Container Container} or layout, and the
 * layout and rendering pipeline is {@link Ext.container.Container#add completely managed by the framework}.&lt;/p&gt;
 * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; By default, the &lt;code&gt;{@link #closable close}&lt;/code&gt; header tool &lt;i&gt;destroys&lt;/i&gt; the Window resulting in
 * destruction of any child Components. This makes the Window object, and all its descendants &lt;b&gt;unusable&lt;/b&gt;. To enable
 * re-use of a Window, use &lt;b&gt;&lt;code&gt;{@link #closeAction closeAction: &#39;hide&#39;}&lt;/code&gt;&lt;/b&gt;.&lt;/p&gt;
 * @constructor
 * @param {Object} config The config object
 * @xtype panel
 */
Ext.define(&#39;Ext.panel.Panel&#39;, {
    extend: &#39;Ext.AbstractPanel&#39;,
    requires: [
        &#39;Ext.panel.Header&#39;,
        &#39;Ext.fx.Anim&#39;,
        &#39;Ext.util.KeyMap&#39;,
        &#39;Ext.panel.DD&#39;,
        &#39;Ext.XTemplate&#39;,
        &#39;Ext.layout.component.Dock&#39;
    ],
    alias: &#39;widget.panel&#39;,
    alternateClassName: &#39;Ext.Panel&#39;,

    <a name="cfg-Ext.panel.Panel-collapsedCls"></a>/**
     * @cfg {String} collapsedCls
     * A CSS class to add to the panel&#39;s element after it has been collapsed (defaults to
     * &lt;code&gt;&#39;x-panel-collapsed&#39;&lt;/code&gt;).
     */

    <a name="cfg-Ext.panel.Panel-animCollapse"></a>/**
     * @cfg {Boolean} animCollapse
     * &lt;code&gt;true&lt;/code&gt; to animate the transition when the panel is collapsed, &lt;code&gt;false&lt;/code&gt; to skip the
     * animation (defaults to &lt;code&gt;true&lt;/code&gt; if the {@link Ext.fx.Anim} class is available, otherwise &lt;code&gt;false&lt;/code&gt;).
     * May also be specified as the animation duration in milliseconds.
     */
    animCollapse: Ext.enableFx,
    
    <a name="cfg-Ext.panel.Panel-minButtonWidth"></a>/**
     * @cfg {Number} minButtonWidth
     * Minimum width of all form buttons in pixels (defaults to &lt;tt&gt;75&lt;/tt&gt;). If set, this will
     * be used as the default value for the &lt;tt&gt;{@link Ext.button.Button#minWidth}&lt;/tt&gt; config of
     * each Button added to the &lt;b&gt;footer toolbar&lt;/b&gt;. Will be ignored for buttons that have this value configured some
     * other way, e.g. in their own config object or via the {@link Ext.Container#config-defaults defaults} of
     * their parent container.
     */
    minButtonWidth: 75,

    <a name="cfg-Ext.panel.Panel-collapsed"></a>/**
     * @cfg {Boolean} collapsed
     * &lt;code&gt;true&lt;/code&gt; to render the panel collapsed, &lt;code&gt;false&lt;/code&gt; to render it expanded (defaults to
     * &lt;code&gt;false&lt;/code&gt;).
     */
    collapsed: false,

    <a name="cfg-Ext.panel.Panel-collapseFirst"></a>/**
     * @cfg {Boolean} collapseFirst
     * &lt;code&gt;true&lt;/code&gt; to make sure the collapse/expand toggle button always renders first (to the left of)
     * any other tools in the panel&#39;s title bar, &lt;code&gt;false&lt;/code&gt; to render it last (defaults to &lt;code&gt;true&lt;/code&gt;).
     */
    collapseFirst: true,

    <a name="cfg-Ext.panel.Panel-hideCollapseTool"></a>/**
     * @cfg {Boolean} hideCollapseTool
     * &lt;code&gt;true&lt;/code&gt; to hide the expand/collapse toggle button when &lt;code&gt;{@link #collapsible} == true&lt;/code&gt;,
     * &lt;code&gt;false&lt;/code&gt; to display it (defaults to &lt;code&gt;false&lt;/code&gt;).
     */
    hideCollapseTool: false,

    <a name="cfg-Ext.panel.Panel-titleCollapse"></a>/**
     * @cfg {Boolean} titleCollapse
     * &lt;code&gt;true&lt;/code&gt; to allow expanding and collapsing the panel (when &lt;code&gt;{@link #collapsible} = true&lt;/code&gt;)
     * by clicking anywhere in the header bar, &lt;code&gt;false&lt;/code&gt;) to allow it only by clicking to tool button
     * (defaults to &lt;code&gt;false&lt;/code&gt;)).
     */
    titleCollapse: true,

    <a name="cfg-Ext.panel.Panel-collapseMode"></a>/**
     * @cfg {String} collapseMode
     * &lt;p&gt;&lt;b&gt;Important: this config is only effective for {@link #collapsible} Panels which are direct child items of a {@link Ext.layout.container.Border border layout}.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;When &lt;i&gt;not&lt;/i&gt; a direct child item of a {@link Ext.layout.container.Border border layout}, then the Panel&#39;s header remains visible, and the body is collapsed to zero dimensions.
     * If the Panel has no header, then a new header (orientated correctly depending on the {@link #collapseDirection}) will be inserted to show a the title and a re-expand tool.&lt;/p&gt;
     * &lt;p&gt;When a child item of a {@link Ext.layout.container.Border border layout}, this config has two options:
     * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;&lt;code&gt;alt&lt;/code&gt;&lt;/b&gt; : &lt;b&gt;Default.&lt;/b&gt;&lt;div class=&quot;sub-desc&quot;&gt;When collapsed, a placeholder Container is injected into the layout to represent the Panel
     * and to provide a UI with a Tool to allow the user to re-expand the Panel.&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;&lt;code&gt;header&lt;/code&gt;&lt;/b&gt; : &lt;div class=&quot;sub-desc&quot;&gt;The Panel collapses to leave a header visible as when not inside a {@link Ext.layout.container.Border border layout}.&lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;&lt;/p&gt;
     */

    <a name="cfg-Ext.panel.Panel-placeHolder"></a>/**
     * @cfg {Mixed} placeHolder
     * &lt;p&gt;&lt;b&gt;Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a {@link Ext.layout.container.Border border layout}
     * when using the default &lt;code&gt;&#39;alt&#39;&lt;/code&gt; {@link #collapseMode}.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;b&gt;Optional.&lt;/b&gt; A Component (or config object for a Component) to show in place of this Panel when this Panel is collapsed by a
     * {@link Ext.layout.container.Border border layout}. Defaults to a generated {@link Ext.panel.Header Header}
     * containing a {@link Ext.panel.Tool Tool} to re-expand the Panel.&lt;/p&gt;
     */

    <a name="cfg-Ext.panel.Panel-floatable"></a>/**
     * @cfg {Boolean} floatable
     * &lt;p&gt;&lt;b&gt;Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a {@link Ext.layout.container.Border border layout}.&lt;/b&gt;&lt;/p&gt;
     * &lt;tt&gt;true&lt;/tt&gt; to allow clicking a collapsed Panel&#39;s {@link #placeHolder} to display the Panel floated
     * above the layout, &lt;tt&gt;false&lt;/tt&gt; to force the user to fully expand a collapsed region by
     * clicking the expand button to see it again (defaults to &lt;tt&gt;true&lt;/tt&gt;).
     */
    floatable: true,

    <a name="cfg-Ext.panel.Panel-collapsible"></a>/**
     * @cfg {Boolean} collapsible
     * &lt;p&gt;True to make the panel collapsible and have an expand/collapse toggle Tool added into
     * the header tool button area. False to keep the panel sized either statically, or by an owning layout manager, with no toggle Tool (defaults to false).&lt;/p&gt;
     * See {@link #collapseMode} and {@link #collapseDirection}
     */
    collapsible: false,

    <a name="cfg-Ext.panel.Panel-collapseDirection"></a>/**
     * @cfg {Boolean} collapseDirection
     * &lt;p&gt;The direction to collapse the Panel when the toggle button is clicked.&lt;/p&gt;
     * &lt;p&gt;Defaults to the {@link #headerPosition}&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Important: This config is &lt;u&gt;ignored&lt;/u&gt; for {@link #collapsible} Panels which are direct child items of a {@link Ext.layout.container.Border border layout}.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;Specify as &lt;code&gt;&#39;top&#39;&lt;/code&gt;, &lt;code&gt;&#39;bottom&#39;&lt;/code&gt;, &lt;code&gt;&#39;left&#39;&lt;/code&gt; or &lt;code&gt;&#39;right&#39;&lt;/code&gt;.&lt;/p&gt;
     */

    <a name="cfg-Ext.panel.Panel-closable"></a>/**
     * @cfg {Boolean} closable
     * &lt;p&gt;True to display the &#39;close&#39; tool button and allow the user to close the window, false to
     * hide the button and disallow closing the window (defaults to &lt;code&gt;false&lt;/code&gt;).&lt;/p&gt;
     * &lt;p&gt;By default, when close is requested by clicking the close button in the header, the {@link #close}
     * method will be called. This will &lt;i&gt;{@link Ext.Component#destroy destroy}&lt;/i&gt; the Panel and its content
     * meaning that it may not be reused.&lt;/p&gt;
     * &lt;p&gt;To make closing a Panel &lt;i&gt;hide&lt;/i&gt; the Panel so that it may be reused, set
     * {@link #closeAction} to &#39;hide&#39;.&lt;/p&gt;
     */
    closable: false,

    <a name="cfg-Ext.panel.Panel-closeAction"></a>/**
     * @cfg {String} closeAction
     * &lt;p&gt;The action to take when the close header tool is clicked:
     * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;&lt;code&gt;&#39;{@link #close}&#39;&lt;/code&gt;&lt;/b&gt; : &lt;b&gt;Default&lt;/b&gt;&lt;div class=&quot;sub-desc&quot;&gt;
     * {@link #close remove} the window from the DOM and {@link Ext.Component#destroy destroy}
     * it and all descendant Components. The window will &lt;b&gt;not&lt;/b&gt; be available to be
     * redisplayed via the {@link #show} method.
     * &lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;&lt;code&gt;&#39;{@link #hide}&#39;&lt;/code&gt;&lt;/b&gt; : &lt;div class=&quot;sub-desc&quot;&gt;
     * {@link #hide} the window by setting visibility to hidden and applying negative offsets.
     * The window will be available to be redisplayed via the {@link #show} method.
     * &lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This behavior has changed! setting *does* affect the {@link #close} method
     * which will invoke the approriate closeAction.
     */
    closeAction: &#39;destroy&#39;,

     <a name="cfg-Ext.panel.Panel-preventHeader"></a>/**
      * @cfg {Boolean} preventHeader Prevent a Header from being created and shown. Defaults to false.
      */
    preventHeader: false,
         
     <a name="cfg-Ext.panel.Panel-headerPosition"></a>/**
      * @cfg {String} headerPosition Specify as &lt;code&gt;&#39;top&#39;&lt;/code&gt;, &lt;code&gt;&#39;bottom&#39;&lt;/code&gt;, &lt;code&gt;&#39;left&#39;&lt;/code&gt; or &lt;code&gt;&#39;right&#39;&lt;/code&gt;. Defaults to &lt;code&gt;&#39;top&#39;&lt;/code&gt;.
      */
    headerPosition: &#39;top&#39;,

     <a name="cfg-Ext.panel.Panel-frame"></a>/**
     * @cfg {Boolean} frame
     * True to apply a frame to the panel.
     */
    frame: false,

    renderTpl: [
        &#39;&lt;div class=&quot;{baseCls}-body&lt;tpl if=&quot;bodyCls&quot;&gt; {bodyCls}&lt;/tpl&gt;&lt;tpl if=&quot;frame&quot;&gt; {baseCls}-body-framed&lt;/tpl&gt;&lt;tpl if=&quot;ui&quot;&gt; {baseCls}-body-{ui}&lt;/tpl&gt;&quot;&lt;tpl if=&quot;bodyStyle&quot;&gt; style=&quot;{bodyStyle}&quot;&lt;/tpl&gt;&gt;&lt;/div&gt;&#39;
    ],

    initComponent: function() {
        var me = this,
            cls;

        me.callParent();
        if (me.unstyled) {
            me.baseCls = me.baseCSSPrefix + &#39;plain&#39;;
        }
        
        if (me.frame) {
            me.ui = &#39;framed&#39;;
        }

        me.collapsedCls = me.collapsedCls || me.baseCls + &#39;-collapsed&#39;;
        me.collapseDirection = me.collapseDirection || me.headerPosition || Ext.Component.DIRECTION_TOP;

        // Backwards compatibility
        me.bridgeToolbars();
    },

    hideBorders : function() {
        var me = this,
            cls = me.baseCls + &#39;-noborder&#39;;

        me.addCls(cls);
        if (me.rendered) {
            me.body.addCls(cls + &#39;-body&#39;);
        }
        else {
            me.renderData.bodyCls = me.renderData.bodyCls || &#39;&#39; + (&#39; &#39; + cls + &#39;-body&#39;);
        }
    },

    showBorders : function() {
        var me = this,
            cls = me.baseCls + &#39;-noborder&#39;;

        me.removeCls(cls);
        if (me.rendered) {
            me.body.removeCls(cls + &#39;-body&#39;);
        }
        else {
            me.renderData.bodyCls = me.renderData.bodyCls.replace(cls + &#39;-body&#39;, &#39;&#39;);
        }
    },

    beforeDestroy: function() {
        Ext.destroy(
            this.ghostPanel
        );
        this.callParent();
    },

    initAria: function() {
        Ext.panel.Panel.superclass.initAria.call(this);
        this.initHeaderAria();
    },

    initHeaderAria: function() {
        var me = this,
            el = me.el,
            header = me.header;
        if (el &amp;&amp; header) {
            el.dom.setAttribute(&#39;aria-labelledby&#39;, header.titleCmp.id);
        }
    },

    <a name="method-Ext.panel.Panel-setTitle"></a>/**
     * Set a title for the panel&#39;s header. See {@link Ext.panel.Header#title}.
     * @param {String} title
     */
    setTitle: function(title) {
        var me = this;
        me.title = title;
        if (me.header) {
            me.header.setTitle(title);
        } else {
            me.updateHeader();
        }
    },

    <a name="method-Ext.panel.Panel-setIconClass"></a>/**
     * Set the iconCls for the panel&#39;s header. See {@link Ext.panel.Header#iconCls}.
     * @param cls
     */
    setIconClass: function(cls) {
        this.iconCls = cls;
        var header = this.header;
        if (header) {
            header.setIconClass(cls);
        }
    },

    initItems: function() {
        // Catch addition of descendant fields
        this.on(&#39;add&#39;, this.onSubCmpAdded, this);
        this.callParent(arguments);
    },

    onSubCmpAdded: function(parent, cmp) {
        var minButtonWidth = this.minButtonWidth;

        if (minButtonWidth &amp;&amp; cmp.isButton/* &amp;&amp; parent &amp;&amp; parent.ui == &#39;footer&#39;*/) {
            if (!cmp.hasOwnProperty(&#39;minWidth&#39;)) {
                cmp.minWidth = minButtonWidth;
            }
        }
    },

    bridgeToolbars: function() {
        var me = this,
            fbar,
            buttons = me.buttons,
            minButtonWidth = me.minButtonWidth,
            initToolbar = function(toolbar, pos) {
                if (Ext.isArray(toolbar)) {
                    toolbar = {
                        xtype: &#39;toolbar&#39;,
                        items: toolbar
                    };
                }
                else if (!toolbar.xtype) {
                    toolbar.xtype = &#39;toolbar&#39;;
                }
                toolbar.dock = pos;
            return toolbar;
        };
        
        // Apply the minButtonWidth config to the items in the &#39;buttons&#39; toolbar config
        if (buttons &amp;&amp; minButtonWidth) {
            Ext.each(buttons, function(button) {
                if (Ext.isObject(button) &amp;&amp; !(&#39;minWidth&#39; in button)) {
                    button.minWidth = minButtonWidth;
                }
            });
        }

        // Backwards compatibility
        if (me.tbar) {
            me.addDocked(initToolbar(me.tbar, &#39;top&#39;));
            me.tbar = null;
        }

        if (me.bbar) {
            me.addDocked(initToolbar(me.bbar, &#39;bottom&#39;));
            me.bbar = null;
        }

        if (me.buttons) {
            me.fbar = me.buttons;
            me.buttons = null;
        }

        if (me.fbar) {
            fbar = initToolbar(me.fbar, &#39;bottom&#39;);
            fbar.ui = &#39;footer&#39;;

            fbar = me.addDocked(fbar)[0];
            fbar.insert(0, {
                flex: 1,
                xtype: &#39;component&#39;
            });
            me.fbar = null;
        }
    },

    <a name="method-Ext.panel.Panel-initTools"></a>/**
     * @private.
     * Tools are a Panel-specific capabilty.
     * Panel uses initTools. Subclasses may contribute tools by implementing addTools.
     */
    initTools: function() {
        var me = this;

        me.tools = me.tools || [];

        // Add a collapse tool unless configured to not show a collapse tool
        // or to not even show a header.
        if (me.collapsible &amp;&amp; !(me.hideCollapseTool || me.header === false)) {
            me.collapseDirection = me.collapseDirection || me.headerPosition || &#39;top&#39;;
            me.collapseTool = me.expandTool = me.createComponent({
                xtype: &#39;tool&#39;,
                type: &#39;collapse-&#39; + me.collapseDirection,
                expandType: me.getOppositeDirection(me.collapseDirection),
                handler: me.toggleCollapse,
                scope: me
            });

            // Prepend collapse tool is configured to do so.
            if (me.collapseFirst) {
                me.tools.unshift(me.collapseTool);
            }
        }

        // Add subclass-specific tools.
        this.addTools();

        // Make Panel closable.
        if (this.closable) {
            this.addCls(this.baseCls + &#39;-closable&#39;);
            this.addTool({
                type: &#39;close&#39;,
                handler: Ext.Function.bind(this.close, this, [])
            });
        }

        // Append collapse tool if needed.
        if (me.collapseTool &amp;&amp; !me.collapseFirst) {
            me.tools.push(me.collapseTool);
        }
    },

    /**
     * @private
     * Template method to be implemented in subclasses to add their tools after the collapsible tool.
     */
    addTools: Ext.emptyFn,

    <a name="method-Ext.panel.Panel-close"></a>/**
     * &lt;p&gt;Closes the Panel. By default, this method, removes it from the DOM, {@link Ext.Component#destroy destroy}s
     * the Panel object and all its descendant Components. The {@link #beforeclose beforeclose}
     * event is fired before the close happens and will cancel the close action if it returns false.&lt;p&gt;
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method is not affected by the {@link #closeAction} setting which
     * only affects the action triggered when clicking the {@link #closable &#39;close&#39; tool in the header}.
     * To hide the Panel without destroying it, call {@link #hide}.&lt;/p&gt;
     */
    close: function() {
        if (this.fireEvent(&#39;beforeclose&#39;, this) !== false) {
            this.doClose();
        }
    },

    // private
    doClose: function() {
        this.fireEvent(&#39;close&#39;, this);
        this[this.closeAction]();
    },

    onRender: function(ct, position) {
        var me = this;

        // Correct border visibility just before render.
        if (me.border === false) {
            me.hideBorders();
        }

        // Add class-specific header tools.
        // Panel adds collapsible and closable.
        me.initTools();

        // Dock the header/title
        me.updateHeader();

        // Call to super after adding the header, to prevent an unnecessary re-layout
        me.callParent(arguments);

        // If initially collapsed, ensure that any header is rendered out, and perform a collapse.
        // collapsed flag must indicate true current state at this point.
        if (me.collapsed) {
            me.header.render(me.el);
            me.header.doComponentLayout();
            me.collapsed = false;
            me.collapse(null, false, true);
        }
    },

    /**
     * Create, hide, or show the header component as appropriate based on the current config.
     * @private
     */
    updateHeader: function() {
        var me = this,
            header = me.header,
            title = me.title,
            tools = me.tools;

        if (!me.preventHeader &amp;&amp; (title || (tools &amp;&amp; tools.length))) {
            if (!header) {
                header = me.header = new Ext.panel.Header({
                    title       : title,
                    orientation : (me.headerPosition == &#39;left&#39; || me.headerPosition == &#39;right&#39;) ? &#39;vertical&#39; : &#39;horizontal&#39;,
                    dock        : me.headerPosition || &#39;top&#39;,
                    textCls     : me.headerTextCls,
                    iconCls     : me.iconCls,
                    baseCls     : me.baseCls + &#39;-header&#39;,
                    tools       : tools,
                    ui          : me.ui,
                    indicateDrag: me.draggable,
                    frame       : me.frame,
                    ignoreParentFrame : me.frame || me.overlapHeader
                });
                me.addDocked(header, 0);

                // Reference the Header&#39;s tool array.
                // Header injects named references.
                me.tools = header.tools;
            }
            header.show();
            this.initHeaderAria();
        }
        else if (header) {
            header.hide();
        }
    },

    // private
    getContentTarget: function() {
        return this.body;
    },

    getTargetEl: function() {
        return this.body || this.frameBody || this.el;
    },

    addTool: function(tool) {
        this.tools.push(tool);
        var header = this.header;
        if (header) {
            header.addTool(tool);
        }
        this.updateHeader();
    },

    getOppositeDirection: function(d) {
        var c = Ext.Component;
        switch (d) {
            case c.DIRECTION_TOP:
                return c.DIRECTION_BOTTOM;
            case c.DIRECTION_RIGHT:
                return c.DIRECTION_LEFT;
            case c.DIRECTION_BOTTOM:
                return c.DIRECTION_TOP;
            case c.DIRECTION_LEFT:
                return c.DIRECTION_RIGHT;
        }
    },

    <a name="method-Ext.panel.Panel-collapse"></a>/**
     * Collapses the panel body so that the body becomes hidden. Docked Components parallel to the
     * border towards which the collapse takes place will remain visible.  Fires the {@link #beforecollapse} event which will
     * cancel the collapse action if it returns false.
     * @param {Number} direction. The direction to collapse towards. Must be one of&lt;ul&gt;
     * &lt;li&gt;Ext.Component.DIRECTION_TOP&lt;/li&gt;
     * &lt;li&gt;Ext.Component.DIRECTION_RIGHT&lt;/li&gt;
     * &lt;li&gt;Ext.Component.DIRECTION_BOTTOM&lt;/li&gt;
     * &lt;li&gt;Ext.Component.DIRECTION_LEFT&lt;/li&gt;&lt;/ul&gt;
     * @param {Boolean} animate True to animate the transition, else false (defaults to the value of the
     * {@link #animCollapse} panel config)
     * @return {Ext.panel.Panel} this
     */
    collapse: function(direction, animate, /* private - passed if called at render time */ internal) {
        var me = this,
            c = Ext.Component,
            height = me.getHeight(),
            width = me.getWidth(),
            newSize = 0,
            dockedItems = me.dockedItems.items,
            dockedItemCount = dockedItems.length,
            i = 0,
            comp,
            pos,
            anim = {
                from: {
                    height: height,
                    width: width
                },
                to: {
                    height: height,
                    width: width
                },
                listeners: {
                    afteranimate: me.afterCollapse,
                    scope: me
                },
                duration: Ext.num(animate, Ext.fx.Anim.prototype.duration)
            },
            reExpander,
            reExpanderOrientation,
            reExpanderDock,
            hideOnCollapse = me.collapseMode == &#39;mini&#39;;

        if (!direction) {
            direction = me.collapseDirection;
        }
        reExpanderDock = direction;
        me.expandDirection = this.getOppositeDirection(direction);

        // Track docked items which he hide during collapsed state
        me.hiddenDocked = [];

        switch (direction) {
            case c.DIRECTION_TOP:
            case c.DIRECTION_BOTTOM:
                me.expandedSize = me.getHeight();
                reExpanderOrientation = &#39;horizontal&#39;;

                // Collect the height of the visible header.
                // Hide all docked items except the header.
                // Hide *ALL* docked items if we&#39;re going to end up hiding the whole Panel anyway
                for (; i &lt; dockedItemCount; i++) {
                    comp = dockedItems[i];
                    if (comp.isVisible()) {
                        if (!hideOnCollapse &amp;&amp; comp.isHeader &amp;&amp; (!comp.dock || comp.dock == &#39;top&#39; || comp.dock == &#39;bottom&#39;)) {
                            newSize += comp.getHeight();
                            reExpander = comp;
                        } else {
                            me.hiddenDocked.push(comp);
                        }
                    }
                }

                anim.to.height = newSize;
                if (direction == Ext.Component.DIRECTION_BOTTOM) {
                    pos = me.getPosition()[1] - Ext.fly(me.el.dom.offsetParent).getRegion().top;
                    anim.from.top = pos;
                }
                break;

            case c.DIRECTION_LEFT:
            case c.DIRECTION_RIGHT:
                me.expandedSize = me.getWidth();
                reExpanderOrientation = &#39;vertical&#39;;

                // Collect the height of the visible header.
                // Hide all docked items except the header.
                // Hide *ALL* docked items if we&#39;re going to end up hiding the whole Panel anyway
                for (; i &lt; dockedItemCount; i++) {
                    comp = dockedItems[i];
                    if (comp.isVisible()) {
                        if (!hideOnCollapse &amp;&amp; comp.isHeader &amp;&amp; (comp.dock == &#39;left&#39; || comp.dock == &#39;right&#39;)) {
                            newSize += comp.getWidth();
                            reExpander = comp;
                        } else {
                            me.hiddenDocked.push(comp);
                        }
                    }
                }

                anim.to.width = newSize;
                if (direction == Ext.Component.DIRECTION_RIGHT) {
                    pos = me.getPosition()[0] - Ext.fly(me.el.dom.offsetParent).getRegion().left;
                    anim.from.left = pos;
                }
                break;

            default:
                throw(&#39;Panel collapse must be passed a valid Component collapse direction&#39;);
        }

        // If internal (called from within Panel&#39;s rendering), then no animation, and no events.
        if (internal) {
            animate = false;
        } else if (me.collapsed || me.fireEvent(&#39;beforecollapse&#39;, me, direction, animate, newSize) === false) {
            return false;
        }

        // No scrollbars when we shrink this Panel
        // And no laying out of any children... we&#39;re effectively *hiding* the body
        me.setAutoScroll(false);
        me.suspendLayout = true;
        me.body.setVisibilityMode(Ext.core.Element.DISPLAY);

        // Disable toggle tool during animated collapse
        if (animate &amp;&amp; me.collapseTool) {
            me.collapseTool.disable();
        }

        // If we&#39;re not in collapseMode: &#39;mini&#39;
        if (!hideOnCollapse) {
            // No placeholder header: Insert one.
            if (!reExpander) {
                reExpander = {
                    temporary: true,
                    title: me.title,
                    orientation: reExpanderOrientation,
                    hideMode: &#39;offsets&#39;,
                    dock: reExpanderDock,
                    textCls: me.headerTextCls,
                    iconCls: me.iconCls,
                    baseCls: me.baseCls + &#39;-header&#39;,
                    ui: me.ui,
                    indicateDrag: me.draggable,
                    cls: me.baseCls + &#39;-collapsed-placeholder &#39; + me.baseCls + &#39;-collapsed-&#39; + direction + &#39;-placeholder&#39;
                };
                reExpander[(reExpander.orientation == &#39;horizontal&#39;) ? &#39;tools&#39; : &#39;items&#39;] = [{
                    xtype: &#39;tool&#39;,
                    type: &#39;expand-&#39; + me.expandDirection,
                    handler: me.toggleCollapse,
                    scope: me
                }];
                reExpander = me.reExpander = new Ext.panel.Header(reExpander);

                // Programatically render it so that it can be measured.
                reExpander.render(me.getTargetEl());
                newSize += (reExpanderOrientation == &#39;vertical&#39;) ? reExpander.getWidth() : reExpander.getHeight();
                reExpander.hide();

                // Insert the new docked item
                me.insertDocked(0, reExpander);
            }

            // Animate to the new size
            anim.to[(reExpanderOrientation == &#39;vertical&#39;) ? &#39;width&#39; : &#39;height&#39;] = newSize;
            me.reExpander = reExpander;

            // If collapsing right or down, we&#39;ll be also animating the left or top.
            if (direction == Ext.Component.DIRECTION_RIGHT) {
                anim.to.left = pos + (width - newSize);
            } else if (direction == Ext.Component.DIRECTION_BOTTOM) {
                anim.to.top = pos + (height - newSize);
            }
        }

        // Remove any flex config before we attempt to collapse.
        me.savedFlex = me.flex;
        me.savedMinWidth = me.minWidth;
        me.savedMinHeight = me.minHeight;
        me.minWidth = 0;
        me.minHeight = 0;
        delete me.flex;

        if (animate) {
            this.animate(anim);
        } else {
            if (!hideOnCollapse) {
                me.setSize(anim.to.width, anim.to.height);
            }
            if (anim.to.x) {
                me.setLeft(anim.to.x);
            }
            if (anim.to.y) {
                me.setTop(anim.to.y);
            }
            me.afterCollapse(false, internal);
        }
        return me;
    },

    afterCollapse: function(animated, internal) {
        var me = this,
            i = 0,
            l = me.hiddenDocked.length,
            hideOnCollapse = me.collapseMode == &#39;mini&#39;;

        me.minWidth = me.savedMinWidth;
        me.minHeight = me.savedMinHeight;
        if (hideOnCollapse) {
            me.el.hide();
            me.hiddenDocked.length = 0;
        }
        else {
            me.body.hide();
            for (; i &lt; l; i++) {
                me.hiddenDocked[i].hide();
            }
        }
        if (me.reExpander) {
            me.reExpander.show();
        }
        me.collapsed = true;
        me.el.addCls(me.collapsedCls);

        // Reinstate laying out of child items
        delete me.suspendLayout;

        if (!internal) {
            if (animated &amp;&amp; me.ownerCt) {
                me.ownerCt.doLayout();
            } else {
                me.doComponentLayout();
            }
        }

        // If me Panel was configured with a collapse tool in its header, flip it&#39;s type
        if (me.collapseTool) {
            me.collapseTool.setType(&#39;expand-&#39; + me.expandDirection);
        }
        if (!internal) {
            me.fireEvent(&#39;collapse&#39;, me);
        }

        // Re-enable the toggle tool after an animated collapse
        if (animated &amp;&amp; me.collapseTool) {
            me.collapseTool.enable();
        }
    },

    <a name="method-Ext.panel.Panel-expand"></a>/**
     * Expands the panel body so that it becomes visible.  Fires the {@link #beforeexpand} event which will
     * cancel the expand action if it returns false.
     * @param {Boolean} animate True to animate the transition, else false (defaults to the value of the
     * {@link #animCollapse} panel config)
     * @return {Ext.panel.Panel} this
     */
    expand: function(animate) {
        if (!this.collapsed || this.fireEvent(&#39;beforeexpand&#39;, this, animate) === false) {
            return false;
        }
        var me = this,
            i = 0,
            l = me.hiddenDocked.length,
            direction = me.expandDirection,
            height = me.getHeight(),
            width = me.getWidth(),
            showOnExpand = me.collapseMode == &#39;mini&#39;,
            pos, anim, satisfyJSLint;

        // Disable toggle tool during animated expand
        if (animate &amp;&amp; me.collapseTool) {
            me.collapseTool.disable();
        }

        // Show any docked items that we hid on collapse
        // And hide the injected reExpander Header
        for (; i &lt; l; i++) {
            me.hiddenDocked[i].show();
        }
        if (me.reExpander &amp;&amp; me.reExpander.temporary) {
            me.reExpander.hide();
        }

        // If me Panel was configured with a collapse tool in its header, flip it&#39;s type
        if (me.collapseTool) {
            me.collapseTool.setType(&#39;collapse-&#39; + me.collapseDirection);
        }

        anim = {
            to: {
            },
            from: {
                height: height,
                width: width
            },
            listeners: {
                afteranimate: me.afterExpand,
                scope: me
            }
        };

        // Unset the flag before the potential call to calculateChildBox to calculate our newly flexed size
        me.collapsed = false;

        if ((direction == Ext.Component.DIRECTION_TOP) || (direction == Ext.Component.DIRECTION_BOTTOM)) {

            // If we were flexed, then we can&#39;t just restore to the saved size.
            // We must restore to the currently correct, flexed size, so we much ask the Box layout what that is.
            if (me.savedFlex) {
                me.flex = me.savedFlex;
                anim.to.height = me.ownerCt.layout.calculateChildBox(me).height;
                delete me.flex;
            } else {
                anim.to.height = me.expandedSize;
            }

            // top needs animating upwards
            if (direction == Ext.Component.DIRECTION_TOP) {
                pos = me.getPosition()[1] - Ext.fly(me.el.dom.offsetParent).getRegion().top;
                anim.from.top = pos;
                anim.to.top = pos - (anim.to.height - height);
            }
        } else if ((direction == Ext.Component.DIRECTION_LEFT) || (direction == Ext.Component.DIRECTION_RIGHT)) {

            // If we were flexed, then we can&#39;t just restore to the saved size.
            // We must restore to the currently correct, flexed size, so we much ask the Box layout what that is.
            if (me.savedFlex) {
                me.flex = me.savedFlex;
                anim.to.width = me.ownerCt.layout.calculateChildBox(me).width;
                delete me.flex;
            } else {
                anim.to.width = me.expandedSize;
            }

            // left needs animating leftwards
            if (direction == Ext.Component.DIRECTION_LEFT) {
                pos = me.getPosition()[0] - Ext.fly(me.el.dom.offsetParent).getRegion().left;
                anim.from.left = pos;
                anim.to.left = pos - (anim.to.width - width);
            }
        }

        if (showOnExpand) {
            me.el.show();
        } else {
            me.body.show();
        }

        // Remove any collapsed styling before any animation begins
        me.el.removeCls(me.collapsedCls);
        if (animate) {
            me.animate(anim);
        } else {
            me.setSize(anim.to.width, anim.to.height);
            if (anim.to.x) {
                me.setLeft(anim.to.x);
            }
            if (anim.to.y) {
                me.setTop(anim.to.y);
            }
            me.afterExpand(false);
        }

        return me;
    },

    afterExpand: function(animated) {
        var me = this;
        me.setAutoScroll(me.initialConfig.autoScroll);

        // Restored to a calculated flex. Delete the set width and height properties so that flex works from now on.
        if (me.savedFlex) {
            me.flex = me.savedFlex;
            delete me.savedFlex;
            delete me.width;
            delete me.height;
        }

        // Reinstate layout out after Panel has re-expanded
        delete me.layout.onLayout;
        if (animated &amp;&amp; me.ownerCt) {
            me.ownerCt.doLayout();
        }

        me.fireEvent(&#39;expand&#39;, me);

        // Re-enable the toggle tool after an animated expand
        if (animated &amp;&amp; me.collapseTool) {
            me.collapseTool.enable();
        }
    },

    <a name="method-Ext.panel.Panel-toggleCollapse"></a>/**
     * Shortcut for performing an {@link #expand} or {@link #collapse} based on the current state of the panel.
     * @return {Ext.panel.Panel} this
     */
    toggleCollapse: function() {
        if (this.collapsed) {
            this.expand(this.animCollapse);
        } else {
            this.collapse(this.collapseDirection, this.animCollapse);
        }
        return this;
    },

    // private
    getKeyMap : function(){
        if(!this.keyMap){
            this.keyMap = new Ext.util.KeyMap(this.el, this.keys);
        }
        return this.keyMap;
    },

    // private
    initDraggable : function(){
        <a name="prop-Ext.panel.Panel-dd"></a>/**
         * &lt;p&gt;If this Panel is configured {@link #draggable}, this property will contain
         * an instance of {@link Ext.dd.DragSource} which handles dragging the Panel.&lt;/p&gt;
         * The developer must provide implementations of the abstract methods of {@link Ext.dd.DragSource}
         * in order to supply behaviour for each stage of the drag/drop process. See {@link #draggable}.
         * @type Ext.dd.DragSource.
         * @property dd
         */
        this.dd = new Ext.panel.DD(this, Ext.isBoolean(this.draggable) ? null : this.draggable);
    },

    // private - used for dragging
    ghost: function(cls) {
        var me = this,
            box = me.getBox();

        if (!me.ghostPanel) {
            me.ghostPanel = new Ext.panel.Panel({
                renderTo: document.body,
                floating: true,
                frame: me.frame,
                title: me.title,
                overlapHeader: me.overlapHeader,
                headerPosition: me.headerPosition,
                width: me.getWidth(),
                height: me.getHeight(),
                baseCls: me.baseCls,
                tools: [{
                    type: &#39;placeholder&#39;
                }],
                cls: me.baseCls + &#39;-ghost &#39; + (cls ||&#39;&#39;)
            });
        }
        me.ghostPanel.floatParent = me.floatParent;
        me.ghostPanel.setZIndex(Ext.num(me.el.getStyle(&#39;zIndex&#39;), 0));
        me.ghostPanel.el.show();
        me.ghostPanel.setPosition(box.x, box.y);
        me.ghostPanel.setSize(box.width, box.height);
        me.el.hide();
        if (me.floatingItems) {
            me.floatingItems.hide();
        }
        return me.ghostPanel;
    },

    // private
    unghost: function(show, matchPosition) {
        var me = this;
        if (!me.ghostPanel) {
            return;
        }
        if (show !== false) {
            me.el.show();
            if (matchPosition !== false) {
                me.setPosition(me.ghostPanel.getPosition());
            }
            if (me.floatingItems) {
                me.floatingItems.show();
            }
            Ext.defer(me.focus, 10, me);
        }
        me.ghostPanel.el.hide();
    },

    // should update body&#39;s el.
    doAutoLoad: function() {

    }
});
￿</pre></pre></body></html>